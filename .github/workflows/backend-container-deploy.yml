name: Backend Container Deploy

on:
  push:
    branches: [ main ]
    paths:
      - Dockerfile
      - requirements.txt
      - engine/**
      - core/**
      - shared/**
      - .github/workflows/backend-container-deploy.yml
  workflow_dispatch: {}

env:
  # Required repo variables (configure in Settings → Variables → Actions)
  ACR_NAME: ${{ vars.ACR_NAME }}
  ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER }}
  AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
  AZURE_WEBAPP_NAME: ${{ vars.AZURE_WEBAPP_NAME }}
  # Optional variables with sensible defaults
  IMAGE_NAME: ${{ vars.IMAGE_NAME || 'infinityai-backend' }}
  DOCKERFILE_PATH: ${{ vars.DOCKERFILE_PATH || 'Dockerfile' }}
  CONTEXT_PATH: ${{ vars.CONTEXT_PATH || '.' }}
  CORS_ALLOW_ORIGINS: ${{ vars.CORS_ALLOW_ORIGINS || 'https://www.infinityai.pro,https://api.infinityai.pro' }}
  APP_PORT: ${{ vars.APP_PORT || '8000' }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      RUN_ALEMBIC: ${{ vars.RUN_ALEMBIC || 'true' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python for Alembic (if enabled)
        if: env.RUN_ALEMBIC == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Alembic deps (if enabled)
        if: env.RUN_ALEMBIC == 'true'
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Export DATABASE_URL (if enabled)
        if: env.RUN_ALEMBIC == 'true'
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_PORT: ${{ vars.DB_PORT || '3306' }}
        run: |
          if [ -z "$DB_HOST" ] || [ -z "$DB_NAME" ] || [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ]; then
            echo "Skipping Alembic: missing DB secrets"; exit 0; fi
          export DATABASE_URL="mysql+pymysql://$DB_USER:$DB_PASSWORD@$DB_HOST:${DB_PORT}/$DB_NAME"
          echo "DATABASE_URL set (masked)"
          echo "DATABASE_URL=$DATABASE_URL" >> $GITHUB_ENV

      - name: Run Alembic migrations (if enabled)
        if: env.RUN_ALEMBIC == 'true'
        env:
            DATABASE_URL: ${{ env.DATABASE_URL }}
        run: |
          if [ -n "$DATABASE_URL" ]; then
            echo "Running alembic upgrade head"
            alembic upgrade head || { echo "Alembic failed"; exit 1; }
          else
            echo "No DATABASE_URL; skipping migrations"
          fi

      - name: Validate required variables
        run: |
          required_vars=(ACR_NAME ACR_LOGIN_SERVER AZURE_RESOURCE_GROUP AZURE_WEBAPP_NAME)
          missing=()
          for v in "${required_vars[@]}"; do
            if [ -z "${!v}" ]; then
              missing+=("$v")
            fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            echo "Missing required repo variables: ${missing[*]}" >&2
            exit 1
          fi

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ACR login
        run: az acr login --name "$ACR_NAME"

      - name: Build and push image
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          echo "Building $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG from $DOCKERFILE_PATH with context $CONTEXT_PATH"
          docker build -f "$DOCKERFILE_PATH" -t "$ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG" "$CONTEXT_PATH"
          docker push "$ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG"
          echo "image_ref=$ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG" >> $GITHUB_ENV

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Configure Web App container
        run: |
          set -euo pipefail
          az webapp config container set \
            --name "$AZURE_WEBAPP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --docker-custom-image-name "$image_ref" \
            --docker-registry-server-url "https://$ACR_LOGIN_SERVER"

      - name: Apply App Settings (port, CORS, DB)
        env:
          # Database secrets (configure in Settings → Secrets and variables → Actions → Secrets)
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_PORT: ${{ vars.DB_PORT || '3306' }}
          DB_CONNECT_TIMEOUT: ${{ vars.DB_CONNECT_TIMEOUT || '5' }}
          # TLS flags (optional)
          DB_SSL_DISABLED: ${{ vars.DB_SSL_DISABLED }}
          DB_SSL_VERIFY: ${{ vars.DB_SSL_VERIFY }}
          DB_SSL_CA: ${{ secrets.DB_SSL_CA }}
          # Optional fallback admin login (temporary access while DB is down)
          ALLOW_FALLBACK_LOGIN: ${{ vars.ALLOW_FALLBACK_LOGIN }}
          ADMIN_USERNAME: ${{ vars.ADMIN_USERNAME }}
          ADMIN_PASSWORD_HASH: ${{ secrets.ADMIN_PASSWORD_HASH }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
          ADMIN_ALLOW_PLAINTEXT: ${{ vars.ADMIN_ALLOW_PLAINTEXT }}
        run: |
          set -euo pipefail
          settings=(
            WEBSITES_PORT=$APP_PORT
            CORS_ALLOW_ORIGINS="$CORS_ALLOW_ORIGINS"
          )
          # Conditionally include DB settings if present
          [ -n "${DB_HOST}" ] && settings+=(DB_HOST=$DB_HOST)
          [ -n "${DB_NAME}" ] && settings+=(DB_NAME=$DB_NAME)
          [ -n "${DB_USER}" ] && settings+=(DB_USER=$DB_USER)
          [ -n "${DB_PASSWORD}" ] && settings+=(DB_PASSWORD=$DB_PASSWORD)
          [ -n "${DB_PORT}" ] && settings+=(DB_PORT=$DB_PORT)
          [ -n "${DB_CONNECT_TIMEOUT}" ] && settings+=(DB_CONNECT_TIMEOUT=$DB_CONNECT_TIMEOUT)
          # TLS flags
          [ -n "${DB_SSL_DISABLED}" ] && settings+=(DB_SSL_DISABLED=$DB_SSL_DISABLED)
          [ -n "${DB_SSL_VERIFY}" ] && settings+=(DB_SSL_VERIFY=$DB_SSL_VERIFY)
          [ -n "${DB_SSL_CA}" ] && settings+=(DB_SSL_CA=$DB_SSL_CA)
          # Fallback admin login
          [ -n "${ALLOW_FALLBACK_LOGIN}" ] && settings+=(ALLOW_FALLBACK_LOGIN=$ALLOW_FALLBACK_LOGIN)
          [ -n "${ADMIN_USERNAME}" ] && settings+=(ADMIN_USERNAME=$ADMIN_USERNAME)
          [ -n "${ADMIN_PASSWORD_HASH}" ] && settings+=(ADMIN_PASSWORD_HASH=$ADMIN_PASSWORD_HASH)
          [ -n "${ADMIN_PASSWORD}" ] && settings+=(ADMIN_PASSWORD=$ADMIN_PASSWORD)
          [ -n "${ADMIN_ALLOW_PLAINTEXT}" ] && settings+=(ADMIN_ALLOW_PLAINTEXT=$ADMIN_ALLOW_PLAINTEXT)

          echo "Applying app settings: ${settings[*]}" | sed -E 's/(DB_PASSWORD|ADMIN_PASSWORD)=[^ ]+/\1=***hidden***/'
          az webapp config appsettings set \
            --name "$AZURE_WEBAPP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --settings ${settings[@]} >/dev/null

      - name: Configure health check
        run: |
          az webapp config set \
            --name "$AZURE_WEBAPP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --health-check-path /health

      - name: Restart Web App
        run: az webapp restart --name "$AZURE_WEBAPP_NAME" --resource-group "$AZURE_RESOURCE_GROUP"
name: backend-container-deploy

on:
  push:
    branches: [ main ]
    paths:
      - 'Dockerfile'
      - 'Dockerfile.azure'
      - 'requirements.txt'
      - 'engine/**'
      - 'shared/**'
      - 'core/**'
      - '.github/workflows/backend-container-deploy.yml'
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  # Customize these via GitHub Repository Variables/Secrets
  ACR_NAME: ${{ vars.ACR_NAME }}               # e.g., infinityaiprodacr
  ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER }} # e.g., infinityaiprodacr.azurecr.io
  RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }} # e.g., infinityai-prod-rg
  WEBAPP_NAME: ${{ vars.AZURE_WEBAPP_NAME }}     # e.g., infinityai-backend-app
  IMAGE_NAME: ${{ vars.IMAGE_NAME || 'infinityai-backend' }}
  DOCKERFILE: ${{ vars.DOCKERFILE || 'Dockerfile' }}
  BUILD_CONTEXT: ${{ vars.BUILD_CONTEXT || '.' }}
  APP_PORT: ${{ vars.APP_PORT || '8000' }}

jobs:
  build-and-push:
    name: Build and push image to ACR
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.image.outputs.image }}
    steps:
      - name: Validate inputs (fail-fast)
        run: |
          set -e
          # Secrets presence
          [ -n "${{ secrets.AZURE_CLIENT_ID }}" ] || { echo "Missing AZURE_CLIENT_ID"; exit 1; }
          [ -n "${{ secrets.AZURE_TENANT_ID }}" ] || { echo "Missing AZURE_TENANT_ID"; exit 1; }
          [ -n "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ] || { echo "Missing AZURE_SUBSCRIPTION_ID"; exit 1; }

          # Variables presence
          [ -n "${{ vars.ACR_NAME }}" ] || { echo "Missing vars.ACR_NAME"; exit 1; }
          [ -n "${{ vars.ACR_LOGIN_SERVER }}" ] || { echo "Missing vars.ACR_LOGIN_SERVER"; exit 1; }
          [ -n "${{ vars.AZURE_RESOURCE_GROUP }}" ] || { echo "Missing vars.AZURE_RESOURCE_GROUP"; exit 1; }
          [ -n "${{ vars.AZURE_WEBAPP_NAME }}" ] || { echo "Missing vars.AZURE_WEBAPP_NAME"; exit 1; }

          # Validate ACR name format: lowercase alphanumeric, 5-50 chars
          if ! echo "${{ vars.ACR_NAME }}" | grep -Eq '^[a-z0-9]{5,50}$'; then
            echo "Invalid ACR_NAME: must be lowercase alphanumeric (5-50)"; exit 1;
          fi
          # Validate login server matches name
          if ! echo "${{ vars.ACR_LOGIN_SERVER }}" | grep -Eq "^${{ vars.ACR_NAME }}\\.azurecr\\.io$"; then
            echo "ACR_LOGIN_SERVER should be '${{ vars.ACR_NAME }}.azurecr.io'"; exit 1;
          fi
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Validate variables
        run: |
          set -e
          echo "ACR_NAME=$ACR_NAME"
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER"
          echo "RESOURCE_GROUP=$RESOURCE_GROUP"
          echo "WEBAPP_NAME=$WEBAPP_NAME"
          test -n "$ACR_NAME" && test -n "$ACR_LOGIN_SERVER" && test -n "$RESOURCE_GROUP" && test -n "$WEBAPP_NAME"

      - name: ACR login
        run: |
          az acr login --name "$ACR_NAME"

      - name: Build image
        run: |
          IMAGE_TAG=${{ github.sha }}
          IMAGE_FULL="$ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG"
          echo "IMAGE_FULL=$IMAGE_FULL" >> $GITHUB_ENV
          docker build -f "$DOCKERFILE" -t "$IMAGE_FULL" "$BUILD_CONTEXT"

      - name: Push image
        run: |
          docker push "$IMAGE_FULL"

      - name: Output image reference
        id: image
        run: echo "image=$IMAGE_FULL" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy to Azure Web App (Container)
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Validate inputs (fail-fast)
        run: |
          set -e
          [ -n "${{ secrets.AZURE_CLIENT_ID }}" ] || { echo "Missing AZURE_CLIENT_ID"; exit 1; }
          [ -n "${{ secrets.AZURE_TENANT_ID }}" ] || { echo "Missing AZURE_TENANT_ID"; exit 1; }
          [ -n "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ] || { echo "Missing AZURE_SUBSCRIPTION_ID"; exit 1; }
          [ -n "${{ vars.ACR_NAME }}" ] || { echo "Missing vars.ACR_NAME"; exit 1; }
          [ -n "${{ vars.ACR_LOGIN_SERVER }}" ] || { echo "Missing vars.ACR_LOGIN_SERVER"; exit 1; }
          [ -n "${{ vars.AZURE_RESOURCE_GROUP }}" ] || { echo "Missing vars.AZURE_RESOURCE_GROUP"; exit 1; }
          [ -n "${{ vars.AZURE_WEBAPP_NAME }}" ] || { echo "Missing vars.AZURE_WEBAPP_NAME"; exit 1; }
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Ensure Web App has AcrPull role to ACR (via managed identity)
        run: |
          set -e
          # Enable system-assigned identity on the Web App (no-op if already enabled)
          PRINCIPAL_ID=$(az webapp identity assign -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query principalId -o tsv)
          echo "WebApp Managed Identity principalId: $PRINCIPAL_ID"

          # Get ACR resource ID
          ACR_ID=$(az acr show -n "$ACR_NAME" --query id -o tsv)
          echo "ACR_ID: $ACR_ID"

          # Assign AcrPull role (idempotent)
          az role assignment create --assignee "$PRINCIPAL_ID" --role AcrPull --scope "$ACR_ID" || echo "AcrPull role may already exist"

      - name: Configure Web App to use container image
        run: |
          set -e
          IMAGE="${{ needs.build-and-push.outputs.image }}"

          echo "Setting container image on Web App: $WEBAPP_NAME => $IMAGE"

          # Set container image (assumes Web App already has permission to pull from ACR)
          az webapp config container set \
            --name "$WEBAPP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --docker-custom-image-name "$IMAGE" \
            --enable-app-service-storage false

          # Ensure port and health path are set
          az webapp config appsettings set \
            --name "$WEBAPP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --settings WEBSITES_PORT=$APP_PORT

          # Health check path to speed up container readiness
          az webapp update \
            --name "$WEBAPP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --set siteConfig.healthCheckPath=/health

          # Optional: If ACR admin is enabled and you prefer registry creds (not recommended), uncomment and set secrets
          # az webapp config container set \
          #   --name "$WEBAPP_NAME" \
          #   --resource-group "$RESOURCE_GROUP" \
          #   --docker-custom-image-name "$IMAGE" \
          #   --docker-registry-server-url "https://$ACR_LOGIN_SERVER" \
          #   --docker-registry-server-user "${{ secrets.ACR_USERNAME }}" \
          #   --docker-registry-server-password "${{ secrets.ACR_PASSWORD }}"

          # Do not restart yet; apply app settings first in the next step

      - name: Apply backend app settings (DB + optional CORS)
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          CORS_ALLOW_ORIGINS: ${{ secrets.CORS_ALLOW_ORIGINS }}
        run: |
          set -e
          SETTINGS="WEBSITES_PORT=$APP_PORT"
          if [ -n "$DB_HOST" ]; then SETTINGS="$SETTINGS DB_HOST=$DB_HOST"; fi
          if [ -n "$DB_NAME" ]; then SETTINGS="$SETTINGS DB_NAME=$DB_NAME"; fi
          if [ -n "$DB_USER" ]; then SETTINGS="$SETTINGS DB_USER=$DB_USER"; fi
          if [ -n "$DB_PASSWORD" ]; then SETTINGS="$SETTINGS DB_PASSWORD=$DB_PASSWORD"; fi
          if [ -n "$CORS_ALLOW_ORIGINS" ]; then SETTINGS="$SETTINGS CORS_ALLOW_ORIGINS=$CORS_ALLOW_ORIGINS"; fi

          echo "Applying app settings: $SETTINGS"
          az webapp config appsettings set \
            --name "$WEBAPP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --settings $SETTINGS

          # Restart to apply image and settings
          az webapp restart --name "$WEBAPP_NAME" --resource-group "$RESOURCE_GROUP"

      - name: Show deployment URL
        run: |
          URL=$(az webapp show -n "$WEBAPP_NAME" -g "$RESOURCE_GROUP" --query defaultHostName -o tsv)
          echo "Deployed to: https://$URL"
